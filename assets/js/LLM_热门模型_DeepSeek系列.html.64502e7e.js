"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[8364],{6995:(t,e)=>{e.A=(t,e)=>{const o=t.__vccOpts||t;for(const[t,n]of e)o[t]=n;return o}},9619:(t,e,o)=>{o.r(e),o.d(e,{comp:()=>r,data:()=>l});var n=o(6254);const a={},r=(0,o(6995).A)(a,[["render",function(t,e){return(0,n.uX)(),(0,n.CE)("div",null,e[0]||(e[0]=[(0,n.Fv)('<h1 id="问题和结论" tabindex="-1"><a class="header-anchor" href="#问题和结论"><span>问题和结论</span></a></h1><ol><li>MOE 能否做知识蒸馏？ 可以</li><li>MOE 相比 Dense 的优势？ 节约计算成本</li><li>什么结构能用 MOE？ 任何 FFN --&gt; 多任务问题</li><li>在已知 MOE 有负载不均衡问题的前提下，为啥目前大模型都开始抛弃传统 Transformer 架构，转投 MOE？ 便宜</li><li>个人原来的理解：MOE 只能节约训练和推理的计算量，不能节约存储量；模型蒸馏可以节约计算量，也可以节约存储量，是否正确？ 正确</li></ol><blockquote><p>错误观点：</p><ol><li>MOE 是为了减小网络结构？ ❌，相反，MOE的初衷是为了在保证较低计算量的同时，增加模型参数，使模型更强</li></ol><p>原来以为MOE是针对深层网络做的优化，将深层网络变为浅层网络，但是实际是将中间层参数数量从 N ，降低为 N/E，分散到E个专家上</p></blockquote><p>与稠密模型相比，对于给定的计算预算，MoE 模型提供更高效的训练。这是因为门控网络仅将 token 发送到一部分专家，从而减少了计算负载。因此，模型的容量（其参数总数）可以增加，而不会成比例地增加计算需求。在推理期间，仅使用部分专家，因此 MoE 能够执行比稠密模型更快的推理。但是，整个模型需要加载到内存中，而不仅仅是正在使用的专家。</p><p>MoE 中实现更高计算效率的稀疏性来自于这样一个事实：特定的 token 只会被路由到一部分专家。专家的数量以及如何选择专家取决于门控网络的实现，但一种常见的方法是 top k。门控网络首先预测每个专家的概率值，然后将 token 路由到 top k 个专家以获得输出。但是，如果所有 token 始终都发送到相同的专家子集，则训练效率会降低，而其他专家最终会训练不足。为了缓解这个问题，引入了负载均衡损失，以鼓励均匀路由到所有专家。</p><p>专家的数量和选择 top k 个专家是设计 MoE 的重要因素。更多的专家数量允许扩展到更大的模型，而不会增加计算成本。这意味着模型具有更高的学习能力，但是，超过某个点后，性能增益往往会减少。选择的专家数量需要与服务模型的推理成本相平衡，因为整个模型都需要加载到内存中。同样，在选择 top k 时，训练期间较低的 top k 会导致较小的矩阵乘法，如果通信成本足够大，则会浪费计算资源。但是，在推理期间，较高的 top k 通常会导致较慢的推理速度。</p><p>https://kevincheung2259.github.io/2024/09/13/MOE-Intro/index.html</p><p>https://deepseek.csdn.net/67fa2941da5d787fd5cb6acb.html</p><p>以Transformer原文中FFN部分的参数量进行计算，如果换成MOE架构，参数量是多少，为啥能够节约计算时间？</p><p>💡从稠密模型到混合专家，再到推理方向</p><p>回顾 DeepSeek 过去一年多发表的核心论文，我们大致能将其研究分为两条主要脉络：</p><ul><li><strong>基座模型（Foundation Models）</strong>：从最早的 Dense（稠密）结构一路演进到 MOE（混合专家）模式，并在这个过程中不断发明和采用新的高效训练算法。</li><li><strong>推理能力（Reasoning）</strong>：包括解数学题、代码生成、逻辑问答乃至定理证明等，更强调大模型的“思考深度”，并在如何进行强化学习方面进行了连续多次创新。</li></ul><p>在阅读这份逐篇解读之前，可以先记住 DeepSeek 的几大特色：对实验和数据极度重视、有足够的冒险精神尝试新架构和新算法、且真正愿意分享内部研究细节，为社区提供可复现的技术报告。</p><h1 id="moe-基本原理" tabindex="-1"><a class="header-anchor" href="#moe-基本原理"><span>MOE 基本原理</span></a></h1><p>MOE全称是Mixture of Experts，也就是混合专家模型</p><h2 id="最最最原始版" tabindex="-1"><a class="header-anchor" href="#最最最原始版"><span>最最最原始版</span></a></h2><p>组成：</p><ol><li>稀疏MOE层：n个专家FFN</li><li>路由：token到top-K个专家。</li></ol><p><img src="https://s08a4grxpw8.feishu.cn/space/api/box/stream/download/asynccode/?code=NWVjNjk1ZmU5YmUyNDA3ZGZlZGQ3MzljZWU5NzVhZWJfQ1pESDhYRFRIM1QwNVEwTzRJSVNCdWZOS1FkNHJ5Q2JfVG9rZW46UnA1M2Jja25Cb2c2MlJ4TTc5SGNtMFE1bmdlXzE3NDU1ODU4NTk6MTc0NTU4OTQ1OV9WNA" alt="img" loading="lazy"><img src="https://s08a4grxpw8.feishu.cn/space/api/box/stream/download/asynccode/?code=NzMzNzMyZWE5ZDFkYjc1MTUwODE0OTViZjI4MWFjNGNfdTRrMVc0UXJnemtRekFWNTNhYzZwMXRBc2plak9naWZfVG9rZW46WE05UmJ3b0VNb05OUTN4MjdVTGNsSXYxbkNuXzE3NDU1ODU4NTk6MTc0NTU4OTQ1OV9WNA" alt="img" loading="lazy"></p><p>FFN</p><ul><li>Vs Transformer</li></ul><figure><img src="https://s08a4grxpw8.feishu.cn/space/api/box/stream/download/asynccode/?code=YjMwMmY0OTI2ZDQ0M2U5MDE2NzlkODc0OTQzNGFiMTNfY1Q3VlhRTGN3VjE4R05QVmF5UEoxbXpVR3hoeHRsb0dfVG9rZW46QU9ieWJvUjY1b3F4SU14c09Cb2NYbEd2bnJjXzE3NDU1ODU4NTk6MTc0NTU4OTQ1OV9WNA" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>一般的gating network的计算，便于和deepseek做对比</li></ul><figure><img src="https://s08a4grxpw8.feishu.cn/space/api/box/stream/download/asynccode/?code=NDkyY2U0NDQ0MzUyYjlmYTg0M2RiMzI2ZTBiNzFiMWZfc1ZwOFpyS1NhdUUwNnJFbGZnUGZkZDRaZnYzb2VpelRfVG9rZW46VEdOQWJnTURab1V1alZ4b3BHQmNmSm5mbldiXzE3NDU1ODU4NTk6MTc0NTU4OTQ1OV9WNA" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="优势" tabindex="-1"><a class="header-anchor" href="#优势"><span>优势</span></a></h3><ul><li>相比dense模型，预训练速度更快</li><li>相比同参数量模型，推理速度更快</li><li>但是需要高 VRAM，因为所有专家都加载在内存中</li></ul><h2 id="switch-transformer" tabindex="-1"><a class="header-anchor" href="#switch-transformer"><span>Switch Transformer</span></a></h2><figure><img src="https://s08a4grxpw8.feishu.cn/space/api/box/stream/download/asynccode/?code=YmE1MzdjZjA0Y2M2YmJhNzZjNGI3NTEyNzE2NmRlZTBfd1FBOXByWnVhUmt1Tm1xanRTcm5ZU0ZKRnhRMTlKTVhfVG9rZW46Umw1dWJJdFdpb3JqcU14NlZsNWNKa2pSbmhkXzE3NDU1ODU4NTk6MTc0NTU4OTQ1OV9WNA" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h1 id="deepseek-moe-2024-01" tabindex="-1"><a class="header-anchor" href="#deepseek-moe-2024-01"><span>DeepSeek MOE(2024.01)</span></a></h1><p>DeepSeek-V1 应该是2023年12月的 DeepSeek LLM Base 和 Chat 模型，是稠密模型</p><p>DeepSeek-V2 及其之后的模型用的都是MoE了</p><p><a href="https://arxiv.org/pdf/2401.06066" target="_blank" rel="noopener noreferrer">DeepSeek MOE原文</a></p><h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景</span></a></h2><ul><li>LLM中，扩展模型参数时节约成本，故使用MoE</li><li>Deepseek MOE就是为了通过更加高效的机制来确保专家之间的任务分配具有更高的专门化性。</li><li>无法确保专家的专门化。这种重叠会导致专家没有获得足够的独特知识，也使得专家之间的差异化不明显，限制了模型的性能和效率。 <ul><li><strong>知识混杂性（Knowledge Hybridity）</strong>：在传统的MoE架构中，通常只使用有限数量的专家（例如8个或16个）。当某个token被分配给某个专家时，这些专家所涵盖的知识往往是多样化的，因此该专家的参数会试图同时存储和处理非常不同类型的知识。这种知识的多样性和复杂性导致专家的知识无法高度专注和聚焦，从而难以在同一模型中有效地利用这些不同类型的知识。</li><li><strong>知识冗余性（Knowledge Redundancy）</strong>：在MoE架构中，不同的专家可能需要共享相同的知识。当多个专家被分配到类似的任务时，它们可能会重复学习和存储相同的知识，这导致了多个专家之间的知识冗余，浪费了存储资源，同时也限制了专家在其各自领域的专门化，使其无法达到 MoE 模型的理论上限性能。</li></ul></li></ul><h2 id="基本思想" tabindex="-1"><a class="header-anchor" href="#基本思想"><span>基本思想</span></a></h2><figure><img src="https://s08a4grxpw8.feishu.cn/space/api/box/stream/download/asynccode/?code=NTE3MTcxZjZkMDM1YzhlZDFiMmExOWUwODhjNTY5YzZfN2E5Z1JOZEZ0UDN6WmR1VFJjc0tmVjhKcnBoTExaS1ZfVG9rZW46WnlSY2JrWm1Tb1BwdTl4T01BR2NUVUJOblVoXzE3NDU1ODU4NTk6MTc0NTU4OTQ1OV9WNA" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="精细化专家划分" tabindex="-1"><a class="header-anchor" href="#精细化专家划分"><span><strong>精细化专家划分</strong></span></a></h3><blockquote><p>划分更细，专家更加专业化，同时可以路由到更多的专家</p></blockquote><p>在保持参数总量不变的情况下，我们通过拆分FFN的中间隐藏层维度来对专家进行更加精细的划分。同时，我们激活更多的精细化专家，从而实现更灵活、更适应的专家组合。精细化的专家划分允许多样化的知识更加细致地分解和学习，从而使每个专家能够专注于更高层次的专业化任务。专家激活的灵活性增加，也有助于更准确和针对性地获取知识。</p><figure><img src="https://s08a4grxpw8.feishu.cn/space/api/box/stream/download/asynccode/?code=NTRlZGY1ODQ0MWU2OGNkMWVhMzZmZjUzZDExNmVjZGNfdTdGTmxHOFhOdjhRVGhVTzJ6ZFdYd01GZGNCZXg1TTVfVG9rZW46VHZHUmJHTjZIbzhzRDF4MlNrcGMyT21HbnlnXzE3NDU1ODU4NTk6MTc0NTU4OTQ1OV9WNA" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="共享专家隔离" tabindex="-1"><a class="header-anchor" href="#共享专家隔离"><span>共享专家隔离</span></a></h3><p>我们将部分专家隔离出来，作为“共享专家”，始终被激活，用于捕捉和整合不同上下文中的共享知识。通过将共享知识压缩到这些共享专家中，减少了其他专家之间的冗余，从而提高了参数的效率，确保每个路由专家能够专注于独特的领域，保持高水平的专门化。</p><figure><img src="https://s08a4grxpw8.feishu.cn/space/api/box/stream/download/asynccode/?code=MjA5N2NhNjE1Y2IzNWE2YmI2NTZhZjcyZjM4MTg3ZmVfeVdSZFRaVmY0UVVnNW1nNlpLejNSU090UGJYVFlYZ0xfVG9rZW46RWtXSGJhZW81b1FUcU14NFd3c2NuNEwwblBkXzE3NDU1ODU4NTk6MTc0NTU4OTQ1OV9WNA" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://s08a4grxpw8.feishu.cn/space/api/box/stream/download/asynccode/?code=YjA5MzYyNjdmYWQ3NzlhNWIzNGI5NTljZTc1Yzg0YzNfTUI2Wk1mN2hORER5MktlUEJHdEFoVGpOWGNZOFJyaUJfVG9rZW46S0ZhYWJOMVp6b1d4bzd4cEs2T2M0Qks2bmRjXzE3NDU1ODU4NTk6MTc0NTU4OTQ1OV9WNA" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="负载均衡问题" tabindex="-1"><a class="header-anchor" href="#负载均衡问题"><span>负载均衡问题</span></a></h3><blockquote><p>MOE类模型的通病</p><p>虽然稀疏门控能在不增加计算成本的情况下显著扩展模型参数空间，但其性能高度依赖门控机制的有效性。门控机制无法控制发给专家的token的概率，所以在实际操作中，会存在专家间工作负载分布不均衡的情况。某些专家被频繁使用（接收到了很多token）而其他专家却很少被调用（接收的token寥寥无几）。这不仅不符合MoE的设计初衷（术业有专攻），还影响计算效率（例如引起分布式训练中各卡通讯时的负载不均）。</p></blockquote><p>负载不均衡会造成：</p><ol><li>模型始终选择少数几个专家，其他专家缺乏充分训练，甚至部分专家参数完全没有更新</li><li>专家并行计算时计算瓶颈（分到16张卡上，花了16张卡的运行时的钱，只有一张卡在工作）</li></ol><p>解决方案：</p><figure><img src="https://s08a4grxpw8.feishu.cn/space/api/box/stream/download/asynccode/?code=YjhmMTA5MzAyZDM1NmNlNDhiYmU3YTA0NzEwZTI2MTRfMTBpQjZqU3FIV0lTR1Q1MDRtMnNuN3h5NzFnWEZrU2tfVG9rZW46VUZaYmJGZ2dxbzhNaHl4R3VtMWNLdUQ2bmhjXzE3NDU1ODU4NTk6MTc0NTU4OTQ1OV9WNA" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="专家级负载均衡" tabindex="-1"><a class="header-anchor" href="#专家级负载均衡"><span>专家级负载均衡</span></a></h4><figure><img src="https://s08a4grxpw8.feishu.cn/space/api/box/stream/download/asynccode/?code=YmNjZjA4YzM1MTQxNjBkYmIwMjZmODNjYmQ3NjEyODNfczVBZ2FQUzd6ZUY2ZUlqMTBxcmNQZWIyaDZzdFNlWGpfVG9rZW46SXpaS2I5dUpDb0t0Umh4OE42RGNCYjNsbkdnXzE3NDU1ODU4NTk6MTc0NTU4OTQ1OV9WNA" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://s08a4grxpw8.feishu.cn/space/api/box/stream/download/asynccode/?code=Mzk3NjM5NDg1YzE5NDVjMGIyODk4ZGZmYjMwM2U0ZWVfY3VBSnllODZ4VnpHcDJCZldzQ1lIOHJRdmp0cUhjRHJfVG9rZW46RnNEQ2I1MW9jb0U2Q1F4VWpZaWNIVW9ObjVmXzE3NDU1ODU4NTk6MTc0NTU4OTQ1OV9WNA" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="设备级负载均衡" tabindex="-1"><a class="header-anchor" href="#设备级负载均衡"><span>设备级负载均衡</span></a></h4><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><p><a href="https://www.cnblogs.com/rossiXYZ/p/18835426#0x00-%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener noreferrer">负载均衡部分参考资料</a></p><h1 id="deepseek-v2" tabindex="-1"><a class="header-anchor" href="#deepseek-v2"><span>DeepSeek-V2</span></a></h1><p>进一步优化负载均衡</p><h1 id="deepseek-v3-reasoning-model" tabindex="-1"><a class="header-anchor" href="#deepseek-v3-reasoning-model"><span>DeepSeek-V3(Reasoning model)</span></a></h1><ol><li>门控函数优化</li></ol><blockquote><p>首先V3的模型远大于V2，V3的每层MOE中有256个路由专家，8个激活专家。但V2中只有160个路由专家，6个激活专家，从参数上就可以发现V3的门控函数计算量远大于V2，大家也都清楚当计算维度变大时SoftMax的前向和反向是很耗费计算资源的，而Sigmod直接将数值映射到[0,1]之间，相对来说更加简单。可能实现效果也类似，因此为了更加高效的训练从而进行了替换。</p></blockquote><ol><li>进一步优化负载均衡 <ol><li>无辅助损失的负载均衡</li><li>互补序列层面的辅助损失</li></ol></li></ol><p>671B的DeepSeek R1，750G的硬盘都671B的权重都塞不下</p><p>上图中(a)表示之前的MOE架构，专家分的粒度比较粗，并且没有共享专家，图（b）是将专家粒度划分的更细情况，图（c）在图(b)的基础上增加了共享专家。</p><p>在 DeepSeek 官网上看到，DeepSeek-V3、V2.5 版本都用了 MoE 架构。但像 Qwen、LLama 模型，用的却是 Dense 架构，也就是传统的 Transformer 架构。这两种架构有个很明显的区别。DeepSeek-V3 版本总参数量高达 6710 亿，可每次计算激活的参数量，也就是真正参与到计算里的参数，只有 370 亿，是总参数量的 5.5%。但 Qwen 和 LLama 模型就不一样了，它们每次计算激活的参数量，就是整个模型的参数量，没有 “打折”。为啥会出现这种差异呢？</p><p>MoE 模型与传统大模型的典型区别：</p><p>MoE 模型：每次输入时，只会激活一小部分专家（例如，10% 的专家），而其他专家不参与计算。这意味着，MoE 模型可以在保持模型参数量很大的情况下，大幅度减少计算量，提高了计算效率和资源利用。</p><p>传统大模型：在传统的大型神经网络（如 Transformer）中，所有层和所有节点在每次前向传播时都会参与计算。虽然这些模型参数也可能非常庞大，但每次输入都需要对所有的参数进行计算，即使部分参数的贡献很小，因此也会浪费计算资源。</p><p>MoE 主要的变化点在 前馈网络（FFN） 层，它被 MoE 机制取代，包括：</p><ol><li>专家网络（Experts）：多个前馈网络（FFN），相当于多个可选的专家，每个专家结构类似于普通 FFN。</li><li>门控网络（Gating Network）：决定在每次输入时，选择哪些专家进行计算，并分配权重。</li><li>专家混合（Mixture of Experts）：选定的专家执行计算，并对其输出进行加权合并。</li></ol><p>其具体工作流程如下：</p><ol><li>输入 token（与传统大模型一致）：</li></ol><p>输入的 token 会首先经过标准的 token embedding 和 位置编码 处理，转化为对应的向量表示。</p><ol><li>多头自注意力（MHSA）层 （与传统大模型一致）</li></ol><p>在多头自注意力层中，token 会计算自己与其他 token 的注意力权重，捕获序列中的长距离依赖关系。这一层的输出是增强了上下文信息的 token 表示，每个 token 在经过多头自注意力层后，会有一个上下文信息丰富的表示，通常是一个向量 h（比如维度为 768 或 1024）。这个向量包含了该 token 在整个句子中上下文的信息，反映了这个 token 和其他 token 的关系。</p><ol><li>MoE 层（变化的地方，包含门控网络、专家网络、专家混合）</li></ol><p>[混合专家模型 (MoE) 详解](https://v11enp9ok1h.feishu.cn/wiki/YC1bwhcyJiQhuJksgO7cVKmqn8e#:~:text=本文讨论了混合专家模型（MoE）的相关内容，包括其与稠密模型相比的优势、结构组成、训练和推理挑战、发展简史、解决问题的方法、不同模型的特点、微调策略、适用场景、优化方法、开源项目以及研究方向等。 关键要点包括： 1.,模型优势：与稠密模型相比，预训练速度更快，相同参数数量下推理速度更快，但需大量显存。 2. 结构组成：由稀疏MoE层和门控网络或路由组成，MoE层含若干专家，门控网络决定令牌路由。)</p><p>https://zhuanlan.zhihu.com/p/21584562624</p><p>https://zhuanlan.zhihu.com/p/21584562624 参考</p><p>MOE的基本原理是使用混合专家来替代原transformer架构中的前向反馈层（FFN），在论文中的示意图如下：</p><p>https://arxiv.org/pdf/2101.03961</p><p>截取下原始论文的参数变化图和框架图</p><p>https://zhuanlan.zhihu.com/p/18565423596</p><p>DeepSeek 在 2T token 上训练了 DeepSeekMoE 16B，激活参数量 2.8B，仅使用了 DeepSeek 7B 和 LLaMA 2 7B 约 40% 的计算量，但评测性能相当。</p><p>https://www.armcvai.cn/2025-02-12/deepseek-moe-code.html</p><p>https://developer.volcengine.com/articles/7476296702404591654 token 的详细解释</p><p>包含 236B 参数，其中每个 token 激活 21B 参数，并支持 128K tokens 的上下文长度。DeepSeek-V2 采用了创新的架构，包括多头潜在注意力（MLA）和 DeepSeekMoE</p><p>与 DeepSeek 67B 相比，DeepSeek-V2 实现了显著更强的性能，同时节省了 42.5% 的训练成本，减少了 93.3% 的 KV 缓存，并将最大生成吞吐量提升了 5.76 倍。</p><p>https://www.youtube.com/watch?v=0BodppoiloM&amp;ab_channel=chaofa%E7%94%A8%E4%BB%A3%E7%A0%81%E6%89%93%E7%82%B9%E9%85%B1%E6%B2%B9</p><p>https://www.youtube.com/watch?v=P7txFafuUOE&amp;t=161s&amp;ab_channel=EZ.EncoderAcademy</p><p>https://arxiv.org/pdf/2401.06066</p><p>https://www.youtube.com/watch?v=G1vC1gjcJEI&amp;ab_channel=TensorOps</p><p>https://www.youtube.com/watch?v=pl38wKk-dHo&amp;ab_channel=AILinkDeepTech</p><p>https://www.youtube.com/watch?v=bd2U-OJ7UJc&amp;ab_channel=GaspardBaye</p><p>https://zhuanlan.zhihu.com/p/18565423596</p><p>https://cloud.tencent.cn/developer/article/2505656?policyId=1004</p><p>为了比较原始 14 层堆叠 Autoencoder 与 2 层 MoE + Autoencoder 的参数差异，我们基于以下假设进行结构化分析：</p><ol><li><strong>原始 14 层堆叠 Autoencoder 的参数计算</strong></li></ol><ul><li><strong>结构假设</strong>：对称编码器-解码器结构，每部分 7 层，逐步降维至 4 维（编码器）后逐步恢复（解码器）。</li><li><strong>参数计算</strong>（以全连接层为例）： <ul><li><strong>编码器路径</strong>： <code>3000 → 1500 → 750 → 375 → 188 → 94 → 47 → 4</code> 每层参数：<code>输入维度×输出维度 + 输出维度</code>（含偏置）。 编码器总参数：<strong>≈6.0M</strong></li><li><strong>解码器路径</strong>： <code>4 → 47 → 94 → 188 → 375 → 750 → 1500 → 3000</code> 解码器总参数：<strong>≈6.0M</strong></li><li><strong>总参数</strong>：编码器 + 解码器 ≈ <strong>12.0M</strong></li></ul></li></ul><ol><li><strong>2 层 MoE + Autoencoder 的参数计算</strong></li></ol><ul><li><strong>结构假设</strong>： <ul><li><strong>编码器</strong>：1 层 MoE（含 2 个专家），直接降维至 4 维。</li><li><strong>解码器</strong>：1 层 MoE（含 2 个专家），从 4 维恢复至 3000 维。</li><li><strong>专家结构</strong>：每个专家为单层全连接网络。</li></ul></li><li><strong>参数计算</strong>： <ul><li><strong>编码器 MoE 层</strong>： <ul><li>每个专家参数：<code>3000×4 + 4 = 12,004</code></li><li>2 个专家总参数：<code>2×12,004 = 24,008</code></li><li>门控网络参数：<code>3000×2 + 2 = 6,002</code></li><li>编码器总参数：<strong>30,010</strong></li></ul></li><li><strong>解码器 MoE 层</strong>： <ul><li>每个专家参数：<code>4×3000 + 3000 = 15,000</code></li><li>2 个专家总参数：<code>2×15,000 = 30,000</code></li><li>门控网络参数：<code>4×2 + 2 = 10</code></li><li>解码器总参数：<strong>30,010</strong></li></ul></li><li><strong>总参数</strong>：编码器 + 解码器 ≈ <strong>60,020</strong></li></ul></li></ul><ol><li><strong>参数减少对比</strong></li></ol><table><thead><tr><th>模型</th><th>总参数</th><th>参数减少比例</th></tr></thead><tbody><tr><td>14层堆叠Autoencoder</td><td>~12,000,000</td><td>-</td></tr><tr><td>2层MoE + Autoencoder</td><td>~60,020</td><td>99.50%</td></tr></tbody></table><ol><li><strong>关键结论</strong></li></ol><ul><li><strong>参数锐减原因</strong>： MoE 通过稀疏激活（仅需少量专家参与计算），结合极简结构设计（单层编码/解码），大幅压缩参数量。</li><li><strong>潜在代价</strong>： 模型容量可能下降，需通过知识蒸馏或专家优化弥补性能损失。</li><li><strong>适用场景</strong>： 资源受限环境（如边缘设备），需轻量化模型且能容忍一定精度损失。</li></ul><ol><li><strong>扩展讨论</strong></li></ol><p>若需平衡性能与参数效率，可尝试：</p><ol><li><strong>增加专家数量</strong>（如 4 个专家），参数仍远低于原始模型（约 120k vs 12M）。</li><li><strong>混合结构</strong>：部分层用 MoE，其余保留全连接层，灵活调节参数与性能。</li><li><strong>知识蒸馏</strong>：用原始 14 层模型作为教师，指导 2 层 MoE 学生模型进一步优化性能。</li></ol><p>以下是原始 14 层堆叠 Autoencoder 与 2 层 MoE+Autoencoder 在推理时间、训练时间和内存占用的详细对比分析：</p><ol><li><strong>推理时间对比</strong></li></ol><table><thead><tr><th>模型</th><th>计算复杂度</th><th>实际推理速度</th><th>关键影响因素</th></tr></thead><tbody><tr><td>14层堆叠Autoencoder</td><td>高</td><td>较慢</td><td>- 深层全连接结构，需逐层计算。 - 参数总量大（12M），计算密集。</td></tr><tr><td>2层MoE+Autoencoder</td><td>低</td><td>较快</td><td>- 仅2层MoE结构，计算步骤少。 - 稀疏激活（每次仅调用少量专家），实际计算量远低于参数总量。 - 门控网络引入额外计算，但总体仍显著节省时间。</td></tr></tbody></table><p><strong>结论</strong>：</p><ul><li><strong>MoE+Autoencoder 推理更快</strong>，得益于稀疏激活和极简层数，尤其适合实时推理场景（如边缘设备）。</li></ul><ol><li><strong>训练时间对比</strong></li></ol><table><thead><tr><th>模型</th><th>收敛速度</th><th>单批次训练时间</th><th>总训练成本</th><th>关键影响因素</th></tr></thead><tbody><tr><td>14层堆叠Autoencoder</td><td>较慢</td><td>长</td><td>高</td><td>- 深层网络梯度传递复杂，易出现梯度消失/爆炸。 - 参数多（12M），反向传播计算量大。</td></tr><tr><td>2层MoE+Autoencoder</td><td>较快</td><td>短</td><td>低</td><td>- 层数少，梯度传递直接。 - 参数少（60k），反向传播高效。 - 需额外优化门控网络与专家负载平衡，可能略微增加调参成本。</td></tr></tbody></table><p><strong>结论</strong>：</p><ul><li><strong>MoE+Autoencoder 训练总时间更短</strong>，但需注意门控网络的稳定性（如专家利用率均衡）。</li></ul><ol><li><strong>内存占用对比</strong></li></ol><h4 id="_3-1-训练阶段内存占用" tabindex="-1"><a class="header-anchor" href="#_3-1-训练阶段内存占用"><span><strong>3.1 训练阶段内存占用</strong></span></a></h4><table><thead><tr><th>模型</th><th>参数内存</th><th>梯度内存</th><th>优化器状态内存</th><th>总内存（float32）</th></tr></thead><tbody><tr><td>14层堆叠Autoencoder</td><td>46 MB</td><td>46 MB</td><td>138 MB（Adam）</td><td>~230 MB</td></tr><tr><td>2层MoE+Autoencoder</td><td>0.23 MB</td><td>0.23 MB</td><td>0.69 MB（Adam）</td><td>~1.15 MB</td></tr></tbody></table><h4 id="_3-2-推理阶段内存占用" tabindex="-1"><a class="header-anchor" href="#_3-2-推理阶段内存占用"><span><strong>3.2 推理阶段内存占用</strong></span></a></h4><table><thead><tr><th>模型</th><th>参数内存（float32）</th><th>激活值内存</th><th>总内存</th></tr></thead><tbody><tr><td>14层堆叠Autoencoder</td><td>46 MB</td><td>高（14层激活）</td><td>~100-200 MB</td></tr><tr><td>2层MoE+Autoencoder</td><td>0.23 MB</td><td>低（2层激活）</td><td>~10-20 MB</td></tr></tbody></table><p><strong>关键说明</strong>：</p><ul><li><strong>MoE+Autoencoder 内存需求极低</strong>，尤其适合内存受限场景（如移动端部署）。</li><li>激活值内存差异显著：深层模型需存储多层中间结果，而 MoE 模型仅需少量层激活。</li></ul><ol><li><strong>综合对比表</strong></li></ol><table><thead><tr><th>指标</th><th>14层堆叠Autoencoder</th><th>2层MoE+Autoencoder</th><th>优势方</th></tr></thead><tbody><tr><td>参数量</td><td>~12.0M</td><td>~60k</td><td>MoE+Autoencoder</td></tr><tr><td>推理时间</td><td>慢</td><td>快</td><td>MoE+Autoencoder</td></tr><tr><td>训练时间</td><td>长</td><td>短</td><td>MoE+Autoencoder</td></tr><tr><td>训练内存</td><td>~230 MB</td><td>~1.15 MB</td><td>MoE+Autoencoder</td></tr><tr><td>推理内存</td><td>~100-200 MB</td><td>~10-20 MB</td><td>MoE+Autoencoder</td></tr><tr><td>模型容量</td><td>高</td><td>较低</td><td>堆叠Autoencoder</td></tr><tr><td>适用场景</td><td>高精度需求</td><td>资源受限环境</td><td>场景依赖</td></tr></tbody></table><ol><li><strong>权衡与建议</strong></li></ol><ul><li><strong>选择 14 层堆叠 Autoencoder</strong>： 需高精度且资源充足（如云端训练/推理），容忍较高延迟和内存消耗。</li><li><strong>选择 2 层 MoE+Autoencoder</strong>： 资源受限（如嵌入式设备）、需快速响应或低内存占用，可接受轻微精度损失。</li><li><strong>优化方向</strong>： 若需兼顾性能与效率，可尝试： <ul><li><strong>知识蒸馏</strong>：用 14 层模型指导 MoE 模型提升精度。</li><li><strong>混合结构</strong>：部分层使用 MoE，平衡参数与容量。</li><li><strong>动态专家数量</strong>：根据输入复杂度调整激活专家数。</li></ul></li></ul><ol><li><strong>总结</strong></li></ol><ul><li><strong>MoE+Autoencoder 在效率上全面占优</strong>，参数、内存、时间均降低 1～2 个数量级。</li><li><strong>堆叠 Autoencoder 在模型容量上占优</strong>，适合对精度要求严格的场景。</li><li>实际选择需结合任务需求、硬件条件及精度-效率权衡。</li></ul>',130)]))}]]),l=JSON.parse('{"path":"/LLM/%E7%83%AD%E9%97%A8%E6%A8%A1%E5%9E%8B/DeepSeek%E7%B3%BB%E5%88%97.html","title":"DeepSeek系列","lang":"zh-CN","frontmatter":{"article":false,"title":"DeepSeek系列","order":2,"description":"问题和结论 MOE 能否做知识蒸馏？ 可以 MOE 相比 Dense 的优势？ 节约计算成本 什么结构能用 MOE？ 任何 FFN --\x3e 多任务问题 在已知 MOE 有负载不均衡问题的前提下，为啥目前大模型都开始抛弃传统 Transformer 架构，转投 MOE？ 便宜 个人原来的理解：MOE 只能节约训练和推理的计算量，不能节约存储量；模型蒸馏可...","head":[["meta",{"property":"og:url","content":"https://jasonaowu.github.io/jasonNote/jasonNote/LLM/%E7%83%AD%E9%97%A8%E6%A8%A1%E5%9E%8B/DeepSeek%E7%B3%BB%E5%88%97.html"}],["meta",{"property":"og:site_name","content":"JasonCC Blog"}],["meta",{"property":"og:title","content":"DeepSeek系列"}],["meta",{"property":"og:description","content":"问题和结论 MOE 能否做知识蒸馏？ 可以 MOE 相比 Dense 的优势？ 节约计算成本 什么结构能用 MOE？ 任何 FFN --\x3e 多任务问题 在已知 MOE 有负载不均衡问题的前提下，为啥目前大模型都开始抛弃传统 Transformer 架构，转投 MOE？ 便宜 个人原来的理解：MOE 只能节约训练和推理的计算量，不能节约存储量；模型蒸馏可..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:image","content":"https://s08a4grxpw8.feishu.cn/space/api/box/stream/download/asynccode/?code=NWVjNjk1ZmU5YmUyNDA3ZGZlZGQ3MzljZWU5NzVhZWJfQ1pESDhYRFRIM1QwNVEwTzRJSVNCdWZOS1FkNHJ5Q2JfVG9rZW46UnA1M2Jja25Cb2c2MlJ4TTc5SGNtMFE1bmdlXzE3NDU1ODU4NTk6MTc0NTU4OTQ1OV9WNA"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-25T12:58:06.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-25T12:58:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"DeepSeek系列\\",\\"description\\":\\"问题和结论 MOE 能否做知识蒸馏？ 可以 MOE 相比 Dense 的优势？ 节约计算成本 什么结构能用 MOE？ 任何 FFN --\x3e 多任务问题 在已知 MOE 有负载不均衡问题的前提下，为啥目前大模型都开始抛弃传统 Transformer 架构，转投 MOE？ 便宜 个人原来的理解：MOE 只能节约训练和推理的计算量，不能节约存储量；模型蒸馏可...\\"}"]]},"git":{"createdTime":1744884980000,"updatedTime":1745585886000,"contributors":[{"name":"morepaperac","username":"morepaperac","email":"jasonaowu@163.com","commits":3,"url":"https://github.com/morepaperac"}]},"readingTime":{"minutes":16.76,"words":5028},"filePathRelative":"LLM/热门模型/DeepSeek系列.md","localizedDate":"2025年4月17日","excerpt":"\\n<ol>\\n<li>MOE 能否做知识蒸馏？  可以</li>\\n<li>MOE 相比 Dense 的优势？  节约计算成本</li>\\n<li>什么结构能用 MOE？  任何 FFN   --&gt; 多任务问题</li>\\n<li>在已知 MOE 有负载不均衡问题的前提下，为啥目前大模型都开始抛弃传统 Transformer 架构，转投 MOE？   便宜</li>\\n<li>个人原来的理解：MOE 只能节约训练和推理的计算量，不能节约存储量；模型蒸馏可以节约计算量，也可以节约存储量，是否正确？  正确</li>\\n</ol>\\n<blockquote>\\n<p>错误观点：</p>\\n<ol>\\n<li>MOE 是为了减小网络结构？ ❌，相反，MOE的初衷是为了在保证较低计算量的同时，增加模型参数，使模型更强</li>\\n</ol>\\n<p>原来以为MOE是针对深层网络做的优化，将深层网络变为浅层网络，但是实际是将中间层参数数量从 N ，降低为 N/E，分散到E个专家上</p>\\n</blockquote>","autoDesc":true}')}}]);