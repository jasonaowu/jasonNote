"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[8364],{2802:(e,a,o)=>{o.r(a),o.d(a,{comp:()=>i,data:()=>l});var n=o(6254);const t={},i=(0,o(6995).A)(t,[["render",function(e,a){return(0,n.uX)(),(0,n.CE)("div",null,a[0]||(a[0]=[(0,n.Fv)('<h2 id="问题和结论" tabindex="-1"><a class="header-anchor" href="#问题和结论"><span>问题和结论</span></a></h2><ol><li>MOE 能否做知识蒸馏？ <span style="color:blue;"><strong>可以</strong></span></li><li>MOE 相比 Dense 的优势？ <span style="color:blue;"><strong>节约计算成本</strong></span></li><li>什么结构能用 MOE？ <span style="color:blue;"><strong>任何 FFN → 多任务问题</strong></span></li><li>在已知 MOE 有负载不均衡问题的前提下，为啥目前大模型都开始抛弃传统 Transformer 架构，转投 MOE？ <span style="color:blue;"><strong>便宜</strong></span></li><li>个人原来的理解：MOE 只能节约训练和推理的计算量，不能节约存储量；模型蒸馏可以节约计算量，也可以节约存储量，是否正确？ <span style="color:blue;"><strong>正确</strong></span></li></ol><blockquote><p><strong>💡错误观点</strong>：</p><ol><li>MOE 是为了减小网络结构？ ❌ 相反，MOE的初衷是为了在保证较低计算量的同时，增加模型参数，使模型更强</li><li>MOE 是为了将深层网络变为浅层网络？ ❌ 将中间层参数数量从 N，降低为 N/E，分散到E个专家上，可能可以将网络变浅，但这不是主要目的 原来以为MOE是针对深层网络做的优化，将深层网络变为浅层网络，但是实际是</li></ol></blockquote><h3 id="deepseek-研究脉络" tabindex="-1"><a class="header-anchor" href="#deepseek-研究脉络"><span>DeepSeek 研究脉络</span></a></h3><p>💡 <strong>从稠密模型到混合专家，再到推理方向</strong></p><p>回顾 DeepSeek 过去一年多发表的核心论文，我们大致能将其研究分为两条主要脉络：</p><ul><li><strong>基座模型（Foundation Models）</strong>：从最早的 Dense（稠密）结构一路演进到 MOE（混合专家）模式，并在这个过程中不断发明和采用新的高效训练算法。</li><li><strong>推理能力（Reasoning）</strong>：包括解数学题、代码生成、逻辑问答乃至定理证明等，更强调大模型的&quot;思考深度&quot;，并在如何进行强化学习方面进行了连续多次创新。</li></ul><h2 id="moe-基本原理" tabindex="-1"><a class="header-anchor" href="#moe-基本原理"><span>MOE 基本原理</span></a></h2><p>MOE 全称是 Mixture of Experts，也就是混合专家模型。</p><p>模型规模是提升模型性能的关键因素之一。在有限的计算资源预算下，用更少的训练步数训练一个更大的模型，往往比用更多的步数训练一个较小的模型效果更佳。</p><p>近期发布的大模型开始广泛转向MOE架构：</p><figure><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/image-20250427011529235.webp" alt="image-20250427011529235" tabindex="0" loading="lazy"><figcaption>image-20250427011529235</figcaption></figure><h3 id="最最最原始版" tabindex="-1"><a class="header-anchor" href="#最最最原始版"><span>最最最原始版</span></a></h3><figure><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/image-20250427012214472.webp" alt="image-20250427012214472" tabindex="0" loading="lazy"><figcaption>image-20250427012214472</figcaption></figure><h4 id="组成" tabindex="-1"><a class="header-anchor" href="#组成"><span>组成</span></a></h4><ol><li><strong>稀疏 MOE 层</strong>：n 个专家 FFN</li><li><strong>路由</strong>：token 到 top-K 个专家</li></ol><p>计算方式如下图</p><figure><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/image-20250427013428021.webp" alt="MOE计算" tabindex="0" loading="lazy"><figcaption>MOE计算</figcaption></figure><h4 id="ffn-对比" tabindex="-1"><a class="header-anchor" href="#ffn-对比"><span>FFN 对比</span></a></h4><ul><li><strong>Vs Transformer</strong></li></ul><figure><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/cb648375-82d9-4f82-9fbe-d2215310d62c.webp" alt="Transformer对比" tabindex="0" loading="lazy"><figcaption>Transformer对比</figcaption></figure><table><thead><tr><th style="text-align:center;"><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/f61ccc9d-e249-4399-b5d5-fe4047576725.webp" alt="FFn" loading="lazy"></th><th style="text-align:center;"><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/c7c02a38-3840-4f5e-ad60-06dc6ece64b2.webp" alt="MOE公式" loading="lazy"></th></tr></thead><tbody><tr><td style="text-align:center;">FFN</td><td style="text-align:center;">MOE</td></tr></tbody></table><ul><li><strong>一般的 gating network 的计算，便于和 deepseek 做对比</strong></li></ul><figure><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/0095a6a0-a489-42cc-86d5-6674fa92d8df.webp" alt="0095a6a0-a489-42cc-86d5-6674fa92d8df" tabindex="0" loading="lazy"><figcaption>0095a6a0-a489-42cc-86d5-6674fa92d8df</figcaption></figure><h4 id="特点" tabindex="-1"><a class="header-anchor" href="#特点"><span>特点</span></a></h4><ul><li>相比 dense 模型，<strong>预训练速度更快</strong></li><li>相比同参数量模型，<strong>推理速度更快</strong></li><li>但是需要高 VRAM，因为所有专家都加载在内存中</li><li>在 <strong>微调方面存在诸多挑战</strong></li></ul><blockquote><p>一个最直观的数据：</p><p>在 DeepSeek 官网上看到，DeepSeek-V3、V2.5 版本都用了 MoE 架构。但像 Qwen、LLama 模型，用的却是 Dense 架构，也就是传统的 Transformer 架构。这两种架构有个很明显的区别。DeepSeek-V3 版本总参数量高达 6710 亿，可每次计算激活的参数量，也就是真正参与到计算里的参数，只有 370 亿，是总参数量的 <span style="color:blue;"><strong>5.5%</strong></span>。但 Qwen 和 LLama 模型就不一样了，它们每次计算激活的参数量，就是整个模型的参数量，没有 “打折”。</p></blockquote><h3 id="switch-transformer" tabindex="-1"><a class="header-anchor" href="#switch-transformer"><span>Switch Transformer</span></a></h3><figure><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/18fc4416-2296-4eb5-910e-a0b5b0984782.webp" alt="18fc4416-2296-4eb5-910e-a0b5b0984782" tabindex="0" loading="lazy"><figcaption>18fc4416-2296-4eb5-910e-a0b5b0984782</figcaption></figure><h3 id="最大问题-负载均衡" tabindex="-1"><a class="header-anchor" href="#最大问题-负载均衡"><span>最大问题-负载均衡</span></a></h3><blockquote><p>可能有的专家更新计算的非常频繁，有的专家根本不动；随着训练的进行，会发现模型会倾向与更新快的专家</p></blockquote><ul><li>门控网络往往倾向于主要激活相同的几个专家。受欢迎的专家训练得更快，因此更容易被选择</li><li>引入了一个<span style="color:blue;"><strong>辅助损失Aux Loss</strong></span>，鼓励所有专家相同的重要性，平衡计算量，使得不同专家学习不同的知识</li><li>Aux Loss确保所有专家接收到大致相等数量的训练样本，从而平衡专家间选择</li></ul><h2 id="deepseek-moe-2024-01" tabindex="-1"><a class="header-anchor" href="#deepseek-moe-2024-01"><span>DeepSeek MOE(2024.01)</span></a></h2><p>DeepSeek-V1 应该是 2023 年 12 月的 DeepSeek LLM Base 和 Chat 模型，是稠密模型。</p><p>DeepSeek-V2 及其之后的模型用的都是 MoE 了。</p><p><a href="https://arxiv.org/pdf/2401.06066" target="_blank" rel="noopener noreferrer">DeepSeek MOE 原文</a></p><h3 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景</span></a></h3><ul><li>LLM 中，<span style="color:blue;"><strong>扩展模型参数时节约成本</strong></span>，故使用 MoE。MOE架构还是很有前途的，但是之前的MOE架构不能很好的稳定的收敛了，每个专家获取的知识差异化不明显。</li><li>Deepseek MOE 就是为了通过更加高效的机制来确保专家之间的任务分配具有更高的<span style="color:blue;"><strong>专门化</strong></span>。</li><li>无法确保专家的专门化：这种重叠会导致专家没有获得足够的独特知识，也使得专家之间的差异化不明显，限制了模型的性能和效率。 <ul><li><strong>知识混杂性（Knowledge Hybridity）</strong>：在传统的 MoE 架构中，通常只使用有限数量的专家（例如 8 个或 16 个）。当某个 token 被分配给某个专家时，这些专家所涵盖的知识往往是多样化的，因此该专家的参数会试图同时存储和处理非常不同类型的知识。这种知识的多样性和复杂性导致专家的知识无法高度专注和聚焦，从而难以在同一模型中有效地利用这些不同类型的知识。</li><li><strong>知识冗余性（Knowledge Redundancy）</strong>：在 MoE 架构中，不同的专家可能需要共享相同的知识。当多个专家被分配到类似的任务时，它们可能会重复学习和存储相同的知识，这导致了多个专家之间的知识冗余，浪费了存储资源，同时也限制了专家在其各自领域的专门化，使其无法达到 MoE 模型的理论上限性能。</li></ul></li></ul><h3 id="基本思想" tabindex="-1"><a class="header-anchor" href="#基本思想"><span>基本思想</span></a></h3><figure><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/37d134bb-b70c-40db-bc79-7e9857fb9364.webp" alt="37d134bb-b70c-40db-bc79-7e9857fb9364" tabindex="0" loading="lazy"><figcaption>37d134bb-b70c-40db-bc79-7e9857fb9364</figcaption></figure><h4 id="精细化专家划分" tabindex="-1"><a class="header-anchor" href="#精细化专家划分"><span><strong>精细化专家划分</strong></span></a></h4><blockquote><p>划分更细，专家更加专业化，同时可以路由到更多的专家</p></blockquote><p>在保持参数总量不变的情况下，我们通过拆分 FFN 的中间隐藏层维度来对专家进行更加精细的划分。同时，我们激活更多的精细化专家，从而实现更灵活、更适应的专家组合。精细化的专家划分允许多样化的知识更加细致地分解和学习，从而使每个专家能够专注于更高层次的专业化任务。专家激活的灵活性增加，也有助于更准确和针对性地获取知识。</p><figure><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1b164aa0-fc5a-4b89-8cff-69294513d65e.webp" alt="1b164aa0-fc5a-4b89-8cff-69294513d65e" tabindex="0" loading="lazy"><figcaption>1b164aa0-fc5a-4b89-8cff-69294513d65e</figcaption></figure><h4 id="共享专家隔离" tabindex="-1"><a class="header-anchor" href="#共享专家隔离"><span><strong>共享专家隔离</strong></span></a></h4><p>我们将部分专家隔离出来，作为“共享专家”，始终被激活，用于捕捉和整合不同上下文中的共享知识。通过将共享知识压缩到这些共享专家中，减少了其他专家之间的冗余，从而提高了参数的效率，确保每个路由专家能够专注于独特的领域，保持高水平的专门化。</p><figure><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/3aeff8bc-1d9d-4e03-a101-fd6d34c6b31e.webp" alt="3aeff8bc-1d9d-4e03-a101-fd6d34c6b31e" tabindex="0" loading="lazy"><figcaption>3aeff8bc-1d9d-4e03-a101-fd6d34c6b31e</figcaption></figure><figure><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/2d03bf2c-1142-416b-8921-739967b392e9.webp" alt="2d03bf2c-1142-416b-8921-739967b392e9" tabindex="0" loading="lazy"><figcaption>2d03bf2c-1142-416b-8921-739967b392e9</figcaption></figure><h4 id="负载均衡问题" tabindex="-1"><a class="header-anchor" href="#负载均衡问题"><span><strong>负载均衡问题</strong></span></a></h4><blockquote><p>MOE 类模型的通病</p><p>虽然稀疏门控能在不增加计算成本的情况下显著扩展模型参数空间，但其性能高度依赖门控机制的有效性。门控机制无法控制发给专家的 token 的概率，所以在实际操作中，会存在专家间工作负载分布不均衡的情况。某些专家被频繁使用（接收到了很多 token）而其他专家却很少被调用（接收的 token 寥寥无几）。这不仅不符合 MoE 的设计初衷（术业有专攻），还影响计算效率（例如引起分布式训练中各卡通讯时的负载不均）。</p></blockquote><p>负载不均衡会造成：</p><ol><li>模型始终选择少数几个专家，其他专家缺乏充分训练，甚至部分专家参数完全没有更新</li><li>专家并行计算时计算瓶颈（分到 16 张卡上，花了 16 张卡的运行时的钱，只有一张卡在工作）</li></ol><p>解决方案：</p><figure><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/ef67d1fe-4a22-4d68-ba99-6c6b94062200.webp" alt="ef67d1fe-4a22-4d68-ba99-6c6b94062200" tabindex="0" loading="lazy"><figcaption>ef67d1fe-4a22-4d68-ba99-6c6b94062200</figcaption></figure><h5 id="专家级负载均衡" tabindex="-1"><a class="header-anchor" href="#专家级负载均衡"><span>专家级负载均衡</span></a></h5><figure><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/893fd346-4dfe-4c4a-9fe9-562173ef022f.webp" alt="893fd346-4dfe-4c4a-9fe9-562173ef022f" tabindex="0" loading="lazy"><figcaption>893fd346-4dfe-4c4a-9fe9-562173ef022f</figcaption></figure><figure><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/24555d94-2d6d-4920-b1df-47016d853dd3.webp" alt="24555d94-2d6d-4920-b1df-47016d853dd3" tabindex="0" loading="lazy"><figcaption>24555d94-2d6d-4920-b1df-47016d853dd3</figcaption></figure><h5 id="设备级负载均衡" tabindex="-1"><a class="header-anchor" href="#设备级负载均衡"><span>设备级负载均衡</span></a></h5><h2 id="deepseek-v2" tabindex="-1"><a class="header-anchor" href="#deepseek-v2"><span>DeepSeek-V2</span></a></h2><p>进一步优化负载均衡</p><h2 id="deepseek-v3-reasoning-model" tabindex="-1"><a class="header-anchor" href="#deepseek-v3-reasoning-model"><span>DeepSeek-V3(Reasoning model)</span></a></h2><ol><li>门控函数优化</li></ol><blockquote><p>首先 V3 的模型远大于 V2，V3 的每层 MOE 中有 256 个路由专家，8 个激活专家。但 V2 中只有 160 个路由专家，6 个激活专家，从参数上就可以发现 V3 的门控函数计算量远大于 V2，大家也都清楚当计算维度变大时 SoftMax 的前向和反向是很耗费计算资源的，而 Sigmod 直接将数值映射到[0，1]之间，相对来说更加简单。可能实现效果也类似，因此为了更加高效的训练从而进行了替换。</p></blockquote><ol><li>进一步优化负载均衡 <ol><li>无辅助损失的负载均衡</li><li>互补序列层面的辅助损失</li></ol></li></ol><ul><li><p>DeepSeek V3和V2模型结构大体一致</p><ul><li>模型层数相差不大，增加模型宽度以及专家数量，调整token路由策略实现负载均衡</li></ul></li><li><p>调整模型超参引入FP8量化</p><ul><li>引入FP8量化减少显存需求，提升训川练效率，降 低训练成本</li></ul></li><li><p>分阶段训练：</p><ul><li>模型效果的提升主要依赖训川练算法的升级(pos t-training,RL、knowledge distillation等)</li></ul></li></ul><figure><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/image-20250427010014303.webp" alt="image-20250427010014303" tabindex="0" loading="lazy"><figcaption>image-20250427010014303</figcaption></figure><h2 id="模型蒸馏" tabindex="-1"><a class="header-anchor" href="#模型蒸馏"><span>模型蒸馏</span></a></h2><blockquote><p>之前的错误理解是MOE可以降低计算量，同时消耗不大的显存。纠错后发现MOE是有做模型蒸馏or模型量化的必要的。</p></blockquote><figure><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/image-20250427011017923.webp" alt="image-20250427011017923" tabindex="0" loading="lazy"><figcaption>image-20250427011017923</figcaption></figure><h2 id="手撕moe" tabindex="-1"><a class="header-anchor" href="#手撕moe"><span>手撕MOE</span></a></h2><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><ul><li><a href="https://kevincheung2259.github.io/2024/09/13/MOE-Intro/index.html" target="_blank" rel="noopener noreferrer">MOE 介绍</a></li><li><a href="https://deepseek.csdn.net/67fa2941da5d787fd5cb6acb.html" target="_blank" rel="noopener noreferrer">DeepSeek 技术解析</a></li><li><a href="https://www.cnblogs.com/rossiXYZ/p/18835426#0x00-%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener noreferrer">负载均衡部分参考资料</a></li></ul>',72)]))}]]),l=JSON.parse('{"path":"/LLM/%E7%83%AD%E9%97%A8%E6%A8%A1%E5%9E%8B/DeepSeek%E7%B3%BB%E5%88%97.html","title":"DeepSeek系列","lang":"zh-CN","frontmatter":{"article":false,"title":"DeepSeek系列","order":2,"description":"问题和结论 MOE 能否做知识蒸馏？ 可以 MOE 相比 Dense 的优势？ 节约计算成本 什么结构能用 MOE？ 任何 FFN → 多任务问题 在已知 MOE 有负载不均衡问题的前提下，为啥目前大模型都开始抛弃传统 Transformer 架构，转投 MOE？ 便宜 个人原来的理解：MOE 只能节约训练和推理的计算量，不能节约存储量；模型蒸馏可以节...","head":[["meta",{"property":"og:url","content":"https://jasonaowu.github.io/jasonNote/jasonNote/LLM/%E7%83%AD%E9%97%A8%E6%A8%A1%E5%9E%8B/DeepSeek%E7%B3%BB%E5%88%97.html"}],["meta",{"property":"og:site_name","content":"JasonCC Blog"}],["meta",{"property":"og:title","content":"DeepSeek系列"}],["meta",{"property":"og:description","content":"问题和结论 MOE 能否做知识蒸馏？ 可以 MOE 相比 Dense 的优势？ 节约计算成本 什么结构能用 MOE？ 任何 FFN → 多任务问题 在已知 MOE 有负载不均衡问题的前提下，为啥目前大模型都开始抛弃传统 Transformer 架构，转投 MOE？ 便宜 个人原来的理解：MOE 只能节约训练和推理的计算量，不能节约存储量；模型蒸馏可以节..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:image","content":"https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/image-20250427011529235.webp"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-26T17:38:34.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-26T17:38:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"DeepSeek系列\\",\\"description\\":\\"问题和结论 MOE 能否做知识蒸馏？ 可以 MOE 相比 Dense 的优势？ 节约计算成本 什么结构能用 MOE？ 任何 FFN → 多任务问题 在已知 MOE 有负载不均衡问题的前提下，为啥目前大模型都开始抛弃传统 Transformer 架构，转投 MOE？ 便宜 个人原来的理解：MOE 只能节约训练和推理的计算量，不能节约存储量；模型蒸馏可以节...\\"}"]]},"git":{"createdTime":1744884980000,"updatedTime":1745689114000,"contributors":[{"name":"morepaperac","username":"morepaperac","email":"jasonaowu@163.com","commits":11,"url":"https://github.com/morepaperac"}]},"readingTime":{"minutes":8.76,"words":2629},"filePathRelative":"LLM/热门模型/DeepSeek系列.md","localizedDate":"2025年4月17日","excerpt":"<h2>问题和结论</h2>\\n<ol>\\n<li>MOE 能否做知识蒸馏？ <span style=\\"color:blue;\\"><strong>可以</strong></span></li>\\n<li>MOE 相比 Dense 的优势？ <span style=\\"color:blue;\\"><strong>节约计算成本</strong></span></li>\\n<li>什么结构能用 MOE？  <span style=\\"color:blue;\\"><strong>任何 FFN → 多任务问题</strong></span></li>\\n<li>在已知 MOE 有负载不均衡问题的前提下，为啥目前大模型都开始抛弃传统 Transformer 架构，转投 MOE？ <span style=\\"color:blue;\\"><strong>便宜</strong></span></li>\\n<li>个人原来的理解：MOE 只能节约训练和推理的计算量，不能节约存储量；模型蒸馏可以节约计算量，也可以节约存储量，是否正确？ <span style=\\"color:blue;\\"><strong>正确</strong></span></li>\\n</ol>","autoDesc":true}')},6995:(e,a)=>{a.A=(e,a)=>{const o=e.__vccOpts||e;for(const[e,n]of a)o[e]=n;return o}}}]);