"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[3389],{751:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>p});var i=a(6254);const e={},l=(0,a(6995).A)(e,[["render",function(n,s){return(0,i.uX)(),(0,i.CE)("div",null,s[0]||(s[0]=[(0,i.Fv)('<h1 id="_215-数组中的第k个最大元素" tabindex="-1"><a class="header-anchor" href="#_215-数组中的第k个最大元素"><span>215. 数组中的第K个最大元素</span></a></h1><h2 id="快排" tabindex="-1"><a class="header-anchor" href="#快排"><span>快排</span></a></h2><h3 id="手写" tabindex="-1"><a class="header-anchor" href="#手写"><span>手写</span></a></h3><p>O(nlogn)</p><ul><li>哨兵划分： 以数组某个元素（一般选取首元素）为基准数，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。</li><li>递归： 对 左子数组 和 右子数组 递归执行 哨兵划分，直至子数组长度为 1 时终止递归，即可完成对整个数组的排序。</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import random</span></span>\n<span class="line"><span>import sys</span></span>\n<span class="line"><span>def quick_sort(nums, start, end):</span></span>\n<span class="line"><span>    if start &gt;= end:</span></span>\n<span class="line"><span>        return </span></span>\n<span class="line"><span>    # 随机生成provix</span></span>\n<span class="line"><span>    provix_idx = random.randint(start, end)</span></span>\n<span class="line"><span>    left, right = start, end</span></span>\n<span class="line"><span>    nums[left], nums[provix_idx] = nums[provix_idx], nums[left]</span></span>\n<span class="line"><span>    x = provix = nums[left]</span></span>\n<span class="line"><span>    while left &lt; right:</span></span>\n<span class="line"><span>        # 初始left 为空，所以先找不合法的right，更新left</span></span>\n<span class="line"><span>        while left &lt; right and nums[right] &gt; x:</span></span>\n<span class="line"><span>            right -= 1</span></span>\n<span class="line"><span>        if left &lt; right:</span></span>\n<span class="line"><span>            nums[left] = nums[right]</span></span>\n<span class="line"><span>            left += 1</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        while left &lt; right and nums[left] &lt; x:</span></span>\n<span class="line"><span>            left += 1</span></span>\n<span class="line"><span>        if left &lt; right:</span></span>\n<span class="line"><span>            nums[right] = nums[left]</span></span>\n<span class="line"><span>            right -= 1</span></span>\n<span class="line"><span>    # 当left = right 的时候，left 为空</span></span>\n<span class="line"><span>    nums[left] = provix</span></span>\n<span class="line"><span>    quick_sort(nums, start, left - 1)  # left 上面放的是基准</span></span>\n<span class="line"><span>    quick_sort(nums, left + 1, end)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>lines = sys.stdin.read().splitlines()</span></span>\n<span class="line"><span>n, k = map(int, lines[0].split())</span></span>\n<span class="line"><span># print(n, k)</span></span>\n<span class="line"><span>nums = list(map(int, lines[1].split()))</span></span>\n<span class="line"><span>quick_sort(nums, 0, n - 1)</span></span>\n<span class="line"><span>print(nums[n - k])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="调库" tabindex="-1"><a class="header-anchor" href="#调库"><span>调库</span></a></h3><p>O(nlogn)</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>class Solution:</span></span>\n<span class="line"><span>    def findKthLargest(self, nums: List[int], k: int) -&gt; int:</span></span>\n<span class="line"><span>        # 按从大到小排序后，输出idx = k - 1</span></span>\n<span class="line"><span>        # nums.sort()</span></span>\n<span class="line"><span>        # nums = nums[::-1]</span></span>\n<span class="line"><span>        nums.sort(reverse = True)</span></span>\n<span class="line"><span>        return nums[k-1]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="快速选择算法-快排变种" tabindex="-1"><a class="header-anchor" href="#快速选择算法-快排变种"><span>快速选择算法--快排变种</span></a></h3><p>O(n) 不用递归处理左右两边了，而是每次缩小为一边 快速选择只需要找到第 k 大或第 k 小的元素，而不是对整个数组进行排序。它的工作流程是通过分区操作递归查找包含目标元素的子数组。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> nums[left] = provix </span></span>\n<span class="line"><span># quick_sort(nums, start, left - 1)</span></span>\n<span class="line"><span># quick_sort(nums, left + 1, end)</span></span>\n<span class="line"><span>if left == len(nums) - k:</span></span>\n<span class="line"><span>\treturn nums[left]</span></span>\n<span class="line"><span>elif left &lt; len(nums) - k:</span></span>\n<span class="line"><span>\tquick_sort(nums, left + 1, end)</span></span>\n<span class="line"><span>else:</span></span>\n<span class="line"><span>\tquick_sort(nums, start, left - 1)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="归并排序" tabindex="-1"><a class="header-anchor" href="#归并排序"><span>归并排序</span></a></h2><h2 id="堆排序" tabindex="-1"><a class="header-anchor" href="#堆排序"><span>堆排序</span></a></h2>',14)]))}]]),p=JSON.parse('{"path":"/InternShip/%E9%9D%A2%E8%AF%95/CodeTop%E7%B3%BB%E5%88%97.html","title":"CodeTop","lang":"zh-CN","frontmatter":{"article":false,"title":"CodeTop","order":2,"description":"215. 数组中的第K个最大元素 快排 手写 O(nlogn) 哨兵划分： 以数组某个元素（一般选取首元素）为基准数，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。 递归： 对 左子数组 和 右子数组 递归执行 哨兵划分，直至子数组长度为 1 时终止递归，即可完成对整个数组的排序。 调库 O(nlogn) 快速选择算法--快排变种 ...","head":[["meta",{"property":"og:url","content":"https://jasonaowu.github.io/jasonNote/jasonNote/InternShip/%E9%9D%A2%E8%AF%95/CodeTop%E7%B3%BB%E5%88%97.html"}],["meta",{"property":"og:site_name","content":"JasonCC Blog"}],["meta",{"property":"og:title","content":"CodeTop"}],["meta",{"property":"og:description","content":"215. 数组中的第K个最大元素 快排 手写 O(nlogn) 哨兵划分： 以数组某个元素（一般选取首元素）为基准数，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。 递归： 对 左子数组 和 右子数组 递归执行 哨兵划分，直至子数组长度为 1 时终止递归，即可完成对整个数组的排序。 调库 O(nlogn) 快速选择算法--快排变种 ..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-19T13:09:35.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-19T13:09:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"CodeTop\\",\\"description\\":\\"215. 数组中的第K个最大元素 快排 手写 O(nlogn) 哨兵划分： 以数组某个元素（一般选取首元素）为基准数，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。 递归： 对 左子数组 和 右子数组 递归执行 哨兵划分，直至子数组长度为 1 时终止递归，即可完成对整个数组的排序。 调库 O(nlogn) 快速选择算法--快排变种 ...\\"}"]]},"git":{"createdTime":1745068175000,"updatedTime":1745068175000,"contributors":[{"name":"morepaperac","username":"morepaperac","email":"jasonaowu@163.com","commits":1,"url":"https://github.com/morepaperac"}]},"readingTime":{"minutes":1.5,"words":451},"filePathRelative":"InternShip/面试/CodeTop系列.md","localizedDate":"2025年4月19日","excerpt":"\\n<h2>快排</h2>\\n<h3>手写</h3>\\n<p>O(nlogn)</p>\\n<ul>\\n<li>哨兵划分： 以数组某个元素（一般选取首元素）为基准数，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。</li>\\n<li>递归： 对 左子数组 和 右子数组 递归执行 哨兵划分，直至子数组长度为 1 时终止递归，即可完成对整个数组的排序。</li>\\n</ul>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>import random</span></span>\\n<span class=\\"line\\"><span>import sys</span></span>\\n<span class=\\"line\\"><span>def quick_sort(nums, start, end):</span></span>\\n<span class=\\"line\\"><span>    if start &gt;= end:</span></span>\\n<span class=\\"line\\"><span>        return </span></span>\\n<span class=\\"line\\"><span>    # 随机生成provix</span></span>\\n<span class=\\"line\\"><span>    provix_idx = random.randint(start, end)</span></span>\\n<span class=\\"line\\"><span>    left, right = start, end</span></span>\\n<span class=\\"line\\"><span>    nums[left], nums[provix_idx] = nums[provix_idx], nums[left]</span></span>\\n<span class=\\"line\\"><span>    x = provix = nums[left]</span></span>\\n<span class=\\"line\\"><span>    while left &lt; right:</span></span>\\n<span class=\\"line\\"><span>        # 初始left 为空，所以先找不合法的right，更新left</span></span>\\n<span class=\\"line\\"><span>        while left &lt; right and nums[right] &gt; x:</span></span>\\n<span class=\\"line\\"><span>            right -= 1</span></span>\\n<span class=\\"line\\"><span>        if left &lt; right:</span></span>\\n<span class=\\"line\\"><span>            nums[left] = nums[right]</span></span>\\n<span class=\\"line\\"><span>            left += 1</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>        while left &lt; right and nums[left] &lt; x:</span></span>\\n<span class=\\"line\\"><span>            left += 1</span></span>\\n<span class=\\"line\\"><span>        if left &lt; right:</span></span>\\n<span class=\\"line\\"><span>            nums[right] = nums[left]</span></span>\\n<span class=\\"line\\"><span>            right -= 1</span></span>\\n<span class=\\"line\\"><span>    # 当left = right 的时候，left 为空</span></span>\\n<span class=\\"line\\"><span>    nums[left] = provix</span></span>\\n<span class=\\"line\\"><span>    quick_sort(nums, start, left - 1)  # left 上面放的是基准</span></span>\\n<span class=\\"line\\"><span>    quick_sort(nums, left + 1, end)</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>lines = sys.stdin.read().splitlines()</span></span>\\n<span class=\\"line\\"><span>n, k = map(int, lines[0].split())</span></span>\\n<span class=\\"line\\"><span># print(n, k)</span></span>\\n<span class=\\"line\\"><span>nums = list(map(int, lines[1].split()))</span></span>\\n<span class=\\"line\\"><span>quick_sort(nums, 0, n - 1)</span></span>\\n<span class=\\"line\\"><span>print(nums[n - k])</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')},6995:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,i]of s)a[n]=i;return a}}}]);